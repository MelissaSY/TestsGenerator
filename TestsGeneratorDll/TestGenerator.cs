using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace TestsGeneratorDll
{
    public class TestGenerator
    {
        public async Task<List<TestClass>> Generate(string sourceCode)
        {
            Dictionary<ClassDeclarationSyntax, List<MethodDeclarationSyntax>> classMethods = new();

            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
            CompilationUnitSyntax root = syntaxTree.GetCompilationUnitRoot();
            return GenerateTests(sourceCode, root);
        }

        private List<TestClass> GenerateTests(string sourceCode, CompilationUnitSyntax root)
        {
            List<TestClass> result = new List<TestClass>();
            var classMethods = AnalyzeRoot(root);
            foreach(var member in classMethods)
            {
                string sourceClassName = member.Key.Identifier.Text;
                var testClass = SyntaxFactory.CompilationUnit();
                string namespaceName = NamespaceName(member.Key);
                testClass = testClass.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(namespaceName)));
                var @namespace = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName($"{namespaceName}.Tests"));
                testClass = testClass.AddUsings(root.Usings.ToArray());
                testClass = testClass.AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("NUnit.Framework")));

                ClassDeclarationSyntax classDeclaration = SyntaxFactory.ClassDeclaration($"{sourceClassName}Tests");
                classDeclaration = classDeclaration.AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword));

                classDeclaration = classDeclaration.AddMembers(GenerateTestMethods(member.Value).ToArray());
                @namespace = @namespace.AddMembers(classDeclaration);

                testClass = testClass.AddMembers(@namespace);

                TestClass @class = new TestClass(sourceClassName, testClass.NormalizeWhitespace().ToFullString());

                result.Add(@class);
            }
            return result;
        }

        public string NamespaceName(ClassDeclarationSyntax classDeclaration)
        {
            string namespaceName = "";

            var @namespace = classDeclaration.Parent as NamespaceDeclarationSyntax;
            if(@namespace != null)
            {
                namespaceName = @namespace.Name.ToString();
            }

            return namespaceName;
        }

        public List<MethodDeclarationSyntax> GenerateTestMethods(List<MethodDeclarationSyntax> sourceMethods)
        {
            List<MethodDeclarationSyntax> methods = new List<MethodDeclarationSyntax>();
            List<string> methodNames = new List<string>();
            foreach(MethodDeclarationSyntax method in sourceMethods)
            {
                string testMethodName = method.Identifier.ToString();
                while(methodNames.Contains(testMethodName)) 
                {
                    testMethodName += "1";
                }
                testMethodName += "Test";

                var methodDeclaration = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), testMethodName);
                methodDeclaration = methodDeclaration.AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword));

                methodDeclaration = methodDeclaration.AddBodyStatements(
                    SyntaxFactory.ExpressionStatement(
                        SyntaxFactory.InvocationExpression(
                            SyntaxFactory.MemberAccessExpression(
                               SyntaxKind.SimpleMemberAccessExpression, 
                               SyntaxFactory.IdentifierName("Assert"), SyntaxFactory.IdentifierName("Fail")),
                            SyntaxFactory.ArgumentList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.Argument(
                                        SyntaxFactory.LiteralExpression(
                                            SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal("autogenerated")
                                            )))))));
                methodDeclaration = methodDeclaration.AddAttributeLists(
                    SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("Test")))));
                
                methods.Add(methodDeclaration);
            }


            return methods;
        }
        public Dictionary<ClassDeclarationSyntax, List<MethodDeclarationSyntax>> AnalyzeRoot(CompilationUnitSyntax root)
        {
            var usings = root.Usings;
            var members = root.Members;

            Dictionary<ClassDeclarationSyntax, List<MethodDeclarationSyntax>> classMethods = new();

            var namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>().ToList();
            var classes = from classDeclaration in root.DescendantNodes().OfType<ClassDeclarationSyntax>()
                           where classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword)
                           select classDeclaration;

            foreach (var classDeclaration in classes)
            {
                var methods = from methodDeclaration in classDeclaration.DescendantNodes().OfType<MethodDeclarationSyntax>()
                             where methodDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword)
                             select methodDeclaration;

                classMethods.Add(classDeclaration, methods.ToList());
            }
            return classMethods;
        }
        
    }
}